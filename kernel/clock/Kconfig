menu "Clocks and Timers"

config ARCH_HAVE_TICKLESS
	bool

config SCHED_TICKLESS
	bool "Support tick-less OS"
	default n
	depends on ARCH_HAVE_TICKLESS
	---help---
		By default, system time is driven by a periodic timer interrupt.  An
		alternative configurations is a tick-less configuration in which
		there is no periodic timer interrupt.  Instead an interval timer is
		used to schedule the next OS time event.  This option selects that
		tick-less OS option.  If the tick-less OS is selected, then there are
		additional platform specific interfaces that must be provided as
		defined in include/nuttx/arch.h

if SCHED_TICKLESS

config SCHED_TICKLESS_TICK_ARGUMENT
	bool "Scheduler use tick argument"
	default n
	---help---
		Enables use of tick argument in scheduler. If enabled, then the
		board-specific logic must provide the following functions:

			int up_timer_gettick(FAR clock_t *ticks);

		If SCHED_TICKLESS_ALARM is enabled, then these additional interfaces are
		expected:

			int up_alarm_tick_cancel(FAR clock_t *ticks);
			int up_alarm_tick_start(clock_t ticks);

		Otherwise, these additional interfaces are expected:

			int up_timer_tick_cancel(FAR clock_t *ticks);
			int up_timer_tick_start(FAR clock_t ticks);

config SCHED_TICKLESS_ALARM
	bool "Tickless alarm"
	default n
	---help---
		The tickless option can be supported either via a simple interval
		timer (plus elapsed time) or via an alarm.  The interval timer allows
		programming events to occur after an interval.  With the alarm,
		you can set a time in the future and get an event when that alarm
		goes off.  This option selects the use of an alarm.

		The advantage of an alarm is that it avoids some small timing
		errors; the advantage of the use of the interval timer is that
		the hardware requirement may be less.

config SCHED_TICKLESS_LIMIT_MAX_SLEEP
	bool "Max sleep period (in microseconds)"
	default n
	---help---
		Enables use of the g_oneshot_maxticks variable. This variable is
		initialized by platform-specific logic at runtime to the maximum
		delay that the timer can wait (in configured clock ticks).  The
		RTOS tickless logic will then limit all requested delays to this
		value.

endif

config USEC_PER_TICK
	int "System timer tick period (microseconds)"
	default 10000 if !SCHED_TICKLESS
	default 100 if SCHED_TICKLESS
	---help---
		In the "normal" configuration where system time is provided by a
		periodic timer interrupt, the default system timer is expected to
		run at 100Hz or USEC_PER_TICK=10000.  This setting must be defined
		to inform of NuttX the interval that the processor hardware is
		providing system timer interrupts to the OS.

		If SCHED_TICKLESS is selected, then there are no system timer
		interrupts.  In this case, USEC_PER_TICK does not control any timer
		rates.  Rather, it only determines the resolution of time reported
		by clock_systime_ticks() and the resolution of times that can be set for
		certain delays including watchdog timers and delayed work.  In this
		case there is a trade-off:  It is better to have the USEC_PER_TICK as
		low as possible for higher timing resolution.  However, the time
		is currently held in 'unsigned int' on some systems, this may be
		16-bits but on most contemporary systems it will be 32-bits.  In
		either case, smaller values of USEC_PER_TICK will reduce the range
		of values that delays that can be represented.  So the trade-off is
		between range and resolution (you could also modify the code to use
		a 64-bit value if you really want both).

		The default, 100 microseconds, will provide for a range of delays
		up to 120 hours.

		This value should never be less than the underlying resolution of
		the timer.  Error may ensue.

config TIMER_ADJUST_USEC
	int "System timer tick adjustment (microseconds)"
	default 0
	---help---
		This value is added to the absolute tick set to the system timer.
		This is used to compensate for interrupt latency in real-time
		systems where the event required to be triggered on exact time.
		The default value of 0 means that no adjustment is made. E.g.
		5 means for each timer being set will be fired 5 microseconds earlier.

if !SCHED_TICKLESS

config SYSTEMTICK_EXTCLK
	bool "Use external clock"
	default n
	depends on ARCH_HAVE_EXTCLK
	---help---
		Use external clock for system tick. When enabled, the platform-specific
		logic must start its own timer interrupt to make periodic calls to the
		nxsched_process_timer() or the functions called within. The purpose is
		to move the scheduling off the processor clock to allow entering low
		power states that would disable that clock.

config SYSTEMTICK_HOOK
	bool "System timer hook"
	default n
	---help---
		Enable a call to a user-provided, board-level function on each timer
		tick.  This permits custom actions that may be performed on each
		timer tick.  The form of the user-provided function is:

			void board_timerhook(void);

		(prototyped in include/nuttx/board.h).

endif # !SCHED_TICKLESS

config SYSTEM_TIME64
	bool "64-bit system clock"
	default n
	---help---
		The system timer is incremented at the rate determined by
		USEC_PER_TICK, typically at 100Hz. The count at any given time is
		then the "uptime" in units of system timer ticks.  By default, the
		system time is 32-bits wide.  Those defaults provide a range of about
		497 days which is probably a sufficient range for "uptime".

		However, if the system timer rate is significantly higher than 100Hz
		and/or if a very long "uptime" is required, then this option can be
		selected to support a 64-bit wide timer.

config ARCH_HAVE_ADJTIME
	bool
	default n

config CLOCK_ADJTIME
	bool "Support adjtime function"
	default n
	depends on ARCH_HAVE_ADJTIME || RTC_ADJTIME
	---help---
		Enables usage of adjtime() interface used to correct the system time
		clock. This requires specific architecture support.

		Adjustment can affect system timer period and/or high-resolution RTC.
		These are implemented by interfaces up_adjtime() and up_rtc_adjtime().

		This is not a POSIX interface but derives from 4.3BSD, System V.
		It is also supported for Linux compatibility.

if CLOCK_ADJTIME

config CLOCK_ADJTIME_SLEWLIMIT_PPM
	int "Adjtime slew limit"
	default 20000
	range 1 1000000
	---help---
		Set limit of adjtime() clock slewing as parts per million.

		In real time systems we do not want the time to adjust too quickly.
		For example CLOCK_ADJTIME_SLEWLIMIT=1000 will slow or speed the timer
		tick period by at most 0.1 percent of the nominal value.

config CLOCK_ADJTIME_PERIOD_MS
	int "Adjtime period"
	default 970
	range 1 3600000
	---help---
		Define system clock adjustment period in milliseconds.
		The adjustment commanded by adjtime() call is applied over this time period.

endif

config ARCH_HAVE_TIMEKEEPING
	bool
	default n

config CLOCK_TIMEKEEPING
	bool "Support timekeeping algorithms"
	default n
	depends on ARCH_HAVE_TIMEKEEPING
	---help---
		CLOCK_TIMEKEEPING enables experimental time management algorithms.

config JULIAN_TIME
	bool "Enables Julian time conversions"
	default n
	---help---
		Enables Julian time conversions

config START_YEAR
	int "Start year"
	default 2018
	range 1970 2106
	---help---
		NuttX uses an unsigned 32-bit integer for time_t which provides a
		range from 1970 to 2106.

config START_MONTH
	int "Start month"
	default 1
	range 1 12

config START_DAY
	int "Start day"
	default 1
	range 1 31

config PREALLOC_TIMERS
	int "Number of pre-allocated POSIX timers"
	default 4 if DEFAULT_SMALL
	default 8 if !DEFAULT_SMALL
	depends on !DISABLE_POSIX_TIMERS
	---help---
		The number of pre-allocated POSIX timer structures.  The system manages a
		pool of preallocated timer structures to minimize dynamic allocations.  Set to
		zero for all dynamic allocations.

config PERF_OVERFLOW_CORRECTION
	bool "Compensate perf count overflow"
	depends on SYSTEM_TIME64 && (ALARM_ARCH || TIMER_ARCH || ARCH_PERF_EVENTS)
	default n
	---help---
		If this option is enabled, then the perf event will be enabled
		by default.
		When enabled, it will always return an increasing count value to
		avoid overflow on 32-bit platforms.

endmenu # Clocks and Timers

menu "Signal Configuration"

config SIG_PREALLOC_ACTIONS
	int "Number of pre-allocated sigactions"
	default 4
	---help---
		The number of pre-allocated sigaction structures.

config SIG_ALLOC_ACTIONS
	int "Num of sigactions to allocate per time"
	default 1
	---help---
		The number of sigactions to allocate per time. Note that
		if this number is larger than 1, the allocation won't be
		returned to the heap but kept in a free list for reuse.

config SIG_PREALLOC_IRQ_ACTIONS
	int "Number of pre-allocated irq actions"
	default 4 if DEFAULT_SMALL
	default 8 if !DEFAULT_SMALL
	---help---
		The number of pre-allocated irq action structures.

config SIG_EVTHREAD
	bool "Support SIGEV_THREAD"
	default n
	depends on !BUILD_KERNEL && SCHED_WORKQUEUE
	select LIBC_USRWORK if BUILD_PROTECTED
	---help---
		Built in support for the SIGEV_THREAD signal deliver method.

		NOTE: The current implementation uses a work queue to notify the
		client.  This, however, would only work in the FLAT build.  A
		different mechanism would need to be development to support this
		feature on the PROTECTED or KERNEL build.

config SIG_EVTHREAD_HPWORK
	bool "SIGEV_EVTHREAD use HPWORK"
	default n
	depends on SIG_EVTHREAD && SCHED_HPWORK
	---help---
		if selected, SIGEV_THREAD will use the high priority work queue.
		If not, it will use the low priority work queue (if available).

		REVISIT:  This solution is non-optimal.  Some notifications should
		be high priority and others should be lower priority.  Ideally, you
		should be able to determine which work queue is used on a
		notification-by-notification basis.

menuconfig SIG_DEFAULT
	bool "Default signal actions"
	default n
	---help---
		Enable to support default signal actions.

if SIG_DEFAULT

comment "Per-signal Default Actions"

config SIG_SIGKILL_ACTION
	bool "Enable all SIGKILL signals"
	default y
	---help---
		Enable the default action for SIGHUP SIGILL SIGTRAP SIGABRT SIGBUS
		SIGFPE SIGINT SIGKILL SIGSEGV SIGQUIT SIGTERM SIGXCPU  SIGXFSZ and
		SIGSYS (terminate the task).

config SIG_SIGUSR1_ACTION
	bool "SIGUSR1"
	default n
	---help---
		Enable the default action for SIGUSR1 (terminate the task)
		Make sure that your applications are expecting this POSIX behavior.
		Backward compatible behavior would require that the application use
		sigaction() to ignore SIGUSR1.

config SIG_SIGUSR2_ACTION
	bool "SIGUSR2"
	default n
	---help---
		Enable the default action for SIGUSR2 (terminate the task)
		Make sure that your applications are expecting this POSIX behavior.
		Backward compatible behavior would require that the application use
		sigaction() to ignore SIGUSR2.

config SIG_SIGPIPE_ACTION
	bool "SIGPIPE"
	default n
	---help---
		Enable the default action for SIGPIPE (terminate the task).

config SIG_SIGALRM_ACTION
	bool "SIGALRM SIGVTALRM"
	default n
	---help---
		Enable the default action for SIGALRM AND SIGVTALRM(terminate the task)
		Make sure that your applications are expecting this POSIX behavior.
		Backward compatible behavior would require that the application use
		sigaction() to ignore SIGALRM.

config SIG_SIGSTOP_ACTION
	bool "SIGSTOP SIGTSTP SIGCONT SIGTTIN SIGTTOU"
	default y
	---help---
		Enable the default action for SIGSTOP SIGTSTP SIGCONT SIGTTIN SIGTTOU
		(suspend the task) and SIGCONT (resume the task).

config SIG_SIGPROF_ACTION
	bool "SIGPROF"
	default n
	---help---
		Enable the default action for SIGPROF (nxsig_abnormal_termination)
		Make sure that your applications are expecting this POSIX behavior.
		Backward compatible behavior would require that the application use
		sigaction() to ignore SIGPROF.

config SIG_SIGPOLL_ACTION
	bool "SIGPOLL"
	default n
	depends on FS_AIO
	---help---
		Enable the default action for SIGPOLL (terminate the task)
		Make sure that your applications are expecting this POSIX behavior.
		Backward compatible behavior would require that the application use
		sigaction() to ignore SIGPOLL.

endif # SIG_DEFAULT

endmenu # Signal Configuration

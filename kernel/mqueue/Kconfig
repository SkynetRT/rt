menu "Message Queue Options"
	depends on !DISABLE_MQUEUE || !DISABLE_MQUEUE_SYSV

config PREALLOC_MQ_MSGS
	int "Number of pre-allocated messages"
	default 4 if DEFAULT_SMALL
	default 8 if !DEFAULT_SMALL
	---help---
		The number of pre-allocated message structures.  The system manages
		a pool of preallocated message structures to minimize dynamic allocations

config PREALLOC_MQ_IRQ_MSGS
	int "Number of pre-allocated irq messages"
	default 4 if DEFAULT_SMALL
	default 8 if !DEFAULT_SMALL
	---help---
		The number of pre-allocated irq message structures.

config MQ_MAXMSGSIZE
	int "Maximum message size"
	default 32
	---help---
		Message structures are allocated with a fixed payload size given by this
		setting (does not include other message structure overhead.

config DISABLE_MQUEUE_NOTIFICATION
	bool "Disable POSIX message queue notification"
	default DEFAULT_SMALL
	---help---
		Disable POSIX message queue notification

config MODULE
	bool "Enable loadable OS modules"
	default n
	select LIBC_ELF
	---help---
		Enable support for loadable OS modules.  Default: n

endmenu # POSIX Message Queue Options

menu "Work queue support"

config SCHED_WORKQUEUE
	bool "Enable worker thread"
	default n
	---help---
		Create dedicated "worker" threads to handle delayed or asynchronous
		processing.

config WQUEUE_NOTIFIER
	bool "Generic work notifier"
	default n
	depends on SCHED_WORKQUEUE
	---help---
		Enable building of work queue notifier logic that will execute a
		worker function an event occurs.  This is is a general purpose
		notifier, but was developed specifically to support poll() logic
		where the poll must wait for an resources to become available.

config SCHED_HPWORK
	bool "High priority (kernel) worker thread"
	default n
	select SCHED_WORKQUEUE
	---help---
		Create a dedicated high-priority "worker" thread to handle delayed
		processing from interrupt handlers.  This feature is required for
		some drivers but, if there are no complaints, can be safely
		disabled.  The high priority worker thread also performs garbage
		collection -- completing any delayed memory deallocations from
		interrupt handlers.  If the high-priority worker thread is disabled,
		then that clean up will be performed either by (1) the low-priority
		worker thread, if enabled, and if not (2) the IDLE thread instead
		(which runs at the lowest of priority and may not be appropriate if
		memory reclamation is of high priority)

		For other, less-critical asynchronous or delayed process, the
		low-priority worker thread is recommended.

if SCHED_HPWORK

config SCHED_HPNTHREADS
	int "Number of high-priority worker threads"
	default 1
	---help---
		This options selects multiple, high-priority threads.  This is
		essentially a "thread pool" that provides multi-threaded servicing
		of the high-priority work queue.  This breaks the serialization
		of the "queue" (hence, it is no longer a queue at all).

		CAUTION: Some drivers may use the work queue to serialize
		operations.  They may also use the high-priority work queue if it is
		available.  If there are multiple high-priority worker threads, then
		this can result in the loss of that serialization.  There may be
		concurrent driver operations running on different HP threads and
		this could lead to a failure.  You may need to visit the use of the
		HP work queue on your configuration is you select
		CONFIG_SCHED_HPNTHREADS > 1

config SCHED_HPWORKPRIORITY
	int "High priority worker thread priority"
	default 224
	---help---
		The execution priority of the higher priority worker thread.

		The higher priority worker thread is intended to serve as the
		"bottom" half for device drivers.  As a consequence it must run at
		a very high, fixed priority.  Typically, it should be the highest
		priority thread in your system.  Default: 224

		For lower priority, application oriented worker thread support,
		please consider enabling the lower priority work queue.  The lower
		priority work queue runs at a lower priority, of course, but has
		the added advantage that it supports "priority inheritance" (if
		PRIORITY_INHERITANCE is also selected):  The priority of the lower
		priority worker thread can then be adjusted to match the highest
		priority client.

config SCHED_HPWORKSTACKSIZE
	int "High priority worker thread stack size"
	default DEFAULT_TASK_STACKSIZE
	---help---
		The stack size allocated for the worker thread.  Default: 2K.

endif # SCHED_HPWORK

config SCHED_LPWORK
	bool "Low priority (kernel) worker thread"
	default n
	select SCHED_WORKQUEUE
	---help---
		If SCHED_LPWORK is defined then a lower-priority work queue will
		be created.  This lower priority work queue is better suited for
		more extended, application oriented processing (such as file system
		clean-up operations or asynchronous I/O)

if SCHED_LPWORK

config SCHED_LPNTHREADS
	int "Number of low-priority worker threads"
	default 1 if !FS_AIO
	default 4 if FS_AIO
	---help---
		This options selects multiple, low-priority threads.  This is
		essentially a "thread pool" that provides multi-threaded servicing
		of the low-priority work queue.  This breaks the serialization
		of the "queue" (hence, it is no longer a queue at all).

		This options is required to support, for example, I/O operations
		that stall waiting for input.  If there is only a single thread,
		then the entire low-priority queue processing stalls in such cases.
		Such behavior is necessary to support asynchronous I/O, AIO (for
		example).

		CAUTION: Some drivers may use the work queue to serialize
		operations.  They may also use the low-priority work queue if it is
		available.  If there are multiple low-priority worker threads, then
		this can result in the loss of that serialization.  There may be
		concurrent driver operations running on different LP threads and
		this could lead to a failure.  You may need to visit the use of the
		LP work queue on your configuration is you select
		CONFIG_SCHED_LPNTHREADS > 1

config SCHED_LPWORKPRIORITY
	int "Low priority worker thread priority"
	default 100
	---help---
		The minimum execution priority of the lower priority worker thread.

		The lower priority worker thread is intended support application-
		oriented functions.  The lower priority work queue runs at a lower
		priority, of course, but has the added advantage that it supports
		"priority inheritance" (if PRIORITY_INHERITANCE is also selected):
		The priority of the lower priority worker thread can then be
		adjusted to match the highest priority client.  Default: 100

		NOTE: This priority inheritance feature is not automatic.  The
		lower priority worker thread will always a fixed priority unless
		you implement logic that calls lpwork_boostpriority() to raise the
		priority of the lower priority worker thread (typically called
		before scheduling the work) and then call the matching
		lpwork_restorepriority() when the work is completed (typically
		called within the work handler at the completion of the work).
		Currently, only the NuttX asynchronous I/O logic uses this dynamic
		prioritization feature.

		The higher priority worker thread, on the other hand, is intended
		to serve as the "bottom" half for device drivers.  As a consequence
		it must run at a very high, fixed priority.  Typically, it should
		be the highest priority thread in your system.

config SCHED_LPWORKPRIOMAX
	int "Low priority worker thread maximum priority"
	default 176
	depends on PRIORITY_INHERITANCE
	---help---
		The maximum execution priority of the lower priority worker thread.

		The lower priority worker thread is intended support application-
		oriented functions.  The lower priority work queue runs at a lower
		priority, of course, but has the added advantage that it supports
		"priority inheritance" (if PRIORITY_INHERITANCE is also selected):
		The priority of the lower priority worker thread can then be
		adjusted to match the highest priority client.

		The higher priority worker thread, on the other hand, is intended
		to serve as the "bottom" half for device drivers.  As a consequence
		it must run at a very high, fixed priority.  Typically, it should
		be the highest priority thread in your system.

		This value provides an upper limit on the priority of the lower
		priority worker thread.  This would be necessary, for example, if
		the higher priority worker thread were to defer work to the lower
		priority thread.  Clearly, in such a case, you would want to limit
		the maximum priority of the lower priority work thread.  Default:
		176

config SCHED_LPWORKSTACKSIZE
	int "Low priority worker thread stack size"
	default DEFAULT_TASK_STACKSIZE
	---help---
		The stack size allocated for the lower priority worker thread.  Default: 2K.

endif # SCHED_LPWORK
endmenu # Work Queue Support

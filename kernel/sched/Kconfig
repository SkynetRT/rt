#
# For a description of the syntax of this configuration file,
# see the file kconfig-language.txt in the NuttX tools repository.
#

menu "POSIX Microkernel"

menuconfig DISABLE_OS_API
	bool "Disable NuttX interfaces"
	default y
	---help---
		The following can be used to disable categories of
		APIs supported by the OS.  If the compiler supports
		weak functions, then it should not be necessary to
		disable functions unless you want to restrict usage
		of those APIs.

if DISABLE_OS_API

config DISABLE_POSIX_TIMERS
	bool "Disable POSIX timers"
	default DEFAULT_SMALL
	---help---
		Disable support for the the entire POSIX timer family
		including timer_create(), timer_gettime(), timer_settime(),
		etc.

		NOTE:  This option will also disable getitimer() and
		setitimer() which are not, strictly speaking, POSIX timers.

config DISABLE_PTHREAD
	bool "Disable pthread support"
	default DEFAULT_SMALL

config DISABLE_MQUEUE
	bool "Disable POSIX message queue support"
	default DEFAULT_SMALL

config DISABLE_MQUEUE_SYSV
	bool "Disable System V message queue support"
	default DISABLE_MQUEUE
	---help---
		Disable System V message queue support

config DISABLE_ENVIRON
	bool "Disable environment variable support"
	default DEFAULT_SMALL

endif # DISABLE_OS_API

config DISABLE_IDLE_LOOP
	bool "Disable idle loop support"
	default n
	---help---
		This option allows nx_start to return instead of
		entering the idle loop.

menu "Performance Monitoring"

config SCHED_SUSPENDSCHEDULER
	bool
	default n

config SCHED_RESUMESCHEDULER
	bool
	default n

config SCHED_IRQMONITOR
	bool "Enable IRQ monitoring"
	default n
	depends on FS_PROCFS
	---help---
		Enabling counting of interrupts from all interrupt sources.  These
		counts will be available in the mounted procfs file systems at the
		top-level file, "irqs".

config SCHED_CRITMONITOR
	bool "Enable Critical Section monitoring"
	default n
	depends on FS_PROCFS
	select SCHED_SUSPENDSCHEDULER
	select SCHED_RESUMESCHEDULER
	select IRQCOUNT
	---help---
		Enables logic that monitors the duration of time that a thread keeps
		interrupts or pre-emption disabled.  These global locks can have
		negative consequences to real time performance:  Disabling interrupts
		adds jitter in the time when an interrupt request is asserted until
		the hardware can respond with the interrupt.  Disabling pre-emption
		adds jitter in the time from when the event is posted in the
		interrupt handler until the task that responds to the event can run.

if SCHED_CRITMONITOR

config SCHED_CRITMONITOR_MAXTIME_THREAD
	int "THREAD max execution time"
	default 0
	---help---
		Thread execution time should be smaller than
		SCHED_CRITMONITOR_MAXTIME_THREAD, or system will give a warning.
		For debugging system latency, 0 means disabled.

config SCHED_CRITMONITOR_MAXTIME_WQUEUE
	int "WORK queue max execution time"
	default -1
	---help---
		Worker execution time should be smaller than
		SCHED_CRITMONITOR_MAXTIME_WQUEUE, or system will give a warning.
		For debugging system latency, 0 means disabled.

config SCHED_CRITMONITOR_MAXTIME_PREEMPTION
	int "Pre-emption (sched_lock) max holding time"
	default SCHED_CRITMONITOR_MAXTIME_WQUEUE
	---help---
		Pre-emption holding time should be smaller than
		SCHED_CRITMONITOR_MAXTIME_PREEMPTION, or system will give a warning.
		For debugging system latency, 0 means disabled.

config SCHED_CRITMONITOR_MAXTIME_CSECTION
	int "Csection (enter_critical_section) max holding time"
	default SCHED_CRITMONITOR_MAXTIME_PREEMPTION
	---help---
		Csection holding time should be smaller than
		SCHED_CRITMONITOR_MAXTIME_CSECTION, or system will give a warning.
		For debugging system latency, 0 means disabled.

config SCHED_CRITMONITOR_MAXTIME_IRQ
	int "IRQ max execution time"
	default SCHED_CRITMONITOR_MAXTIME_CSECTION
	---help---
		IRQ handler execution time should be smaller than
		SCHED_CRITMONITOR_MAXTIME_IRQ, or system will give a warning.
		For debugging system latency, 0 means disabled.

config SCHED_CRITMONITOR_MAXTIME_WDOG
	int "WDOG callback max execution time"
	default SCHED_CRITMONITOR_MAXTIME_IRQ
	---help---
		Wdog callback execution time should be smaller than
		SCHED_CRITMONITOR_MAXTIME_WDOG, or system will give a warning.
		For debugging system latency, 0 means disabled.

endif # SCHED_CRITMONITOR

config SCHED_CRITMONITOR_MAXTIME_PANIC
	bool "Monitor timeout panic"
	depends on \
		SCHED_CRITMONITOR_MAXTIME_THREAD > 0 || \
		SCHED_CRITMONITOR_MAXTIME_WDOG > 0 || \
		SCHED_CRITMONITOR_MAXTIME_WQUEUE > 0 || \
		SCHED_CRITMONITOR_MAXTIME_PREEMPTION > 0 || \
		SCHED_CRITMONITOR_MAXTIME_CSECTION > 0 || \
		SCHED_CRITMONITOR_MAXTIME_IRQ > 0
	default n
	---help---
		If this option is enabled, a panic will be triggered when
		IRQ/WQUEUE/PREEMPTION execution time exceeds SCHED_CRITMONITOR_MAXTIME_xxx

choice
	prompt "Select CPU load clock source"
	default SCHED_CPULOAD_NONE
	---help---
		If this option is selected, the timer interrupt handler will monitor
		if the system is IDLE or busy at the time of that the timer interrupt
		occurs.  This is a very coarse measurement, but over a period of time,
		it can very accurately determine the percentage of the time that the
		CPU is IDLE.

		The statistics collected in this could be used, for example, in the
		PROCFS file system to provide CPU load measurements when read.

		Note that in tickless mode of operation (SCHED_TICKLESS) there is
		no system timer interrupt and CPU load measurements will not be
		possible unless you provide an alternative clock to drive the
		sampling and select SCHED_CPULOAD_EXTCLK.

config SCHED_CPULOAD_NONE
	bool "None CPU load clock source"
	---help---
		If this option is enabled, the system will not support CPU load
		measurement.

config SCHED_CPULOAD_SYSCLK
	bool "Use system clock"
	---help---
		If this option is enabled, the system clock is used for cpu load
		measurement by default.

		There is a serious issue for the accuracy of measurements if the
		system clock is used, however.  NuttX threads are often started at
		the time of the system timer expiration.  Others may be stopped at
		the time of the system timer expiration (if round-robin time-slicing
		is enabled).  Such thread behavior occurs synchronously with the
		system timer and, hence, is not randomly sampled.  As a consequence,
		the CPU load attributed to these threads that run synchronously with
		they system timer may be grossly in error.
		The CPU load measurements are determined by sampling the active
		tasks periodically at the occurrence to a timer expiration.
		If tickless is enabled, SYSCLK should not be used. Its error will be
		very large, and using it for analysis will lead to wrong conclusions.

config SCHED_CPULOAD_EXTCLK
	bool "Use external clock"
	---help---
		There is a serious issue for the accuracy of measurements if the
		system clock is used, however.  NuttX threads are often started at
		the time of the system timer expiration.  Others may be stopped at
		the time of the system timer expiration (if round-robin time-slicing
		is enabled).  Such thread behavior occurs synchronously with the
		system timer and, hence, is not randomly sampled.  As a consequence,
		the CPU load attributed to these threads that run synchronously with
		they system timer may be grossly in error.

		The solution is to use some other clock that runs at a different
		rate and has timer expirations that are asynchronous with the
		system timer.  Then truly accurate load measurements can be
		achieved.  This option enables use of such an "external" clock.  The
		implementation of the clock must be provided by platform-specific
		logic; that platform-specific logic must call the system function
		nxsched_process_cpuload_ticks() at each timer expiration with interrupts
		disabled.

config SCHED_CPULOAD_CRITMONITOR
	bool "Use critical monitor"
	depends on SCHED_CRITMONITOR_MAXTIME_THREAD >= 0
	---help---
		Use the perfcounter in the core of the chip as a counter, no need to
		use an external timer. Need to depend on SCHED_CRITMONITOR.
		When the task is suspended, call nxsched_critmon_cpuload_ticks to count
		the recent running time of the task

endchoice

config SCHED_CPULOAD_TICKSPERSEC
	int "CPU load sampling clock frequency(HZ)"
	default 100
	---help---
		CPU load sampling clock frequency, in HZ. Use sysclk clock source,
		use wdt, EXTCLK clock source, use an external timer.
		The default value of 100 corresponds to a 100Hz clock.  NOTE:
		that 100Hz is the default frequency of the system time and, hence,
		the worst possible choice in most cases.

if SCHED_CPULOAD_EXTCLK

choice
	prompt "Select CPU load timer"
	default CPULOAD_ONESHOT

config CPULOAD_ONESHOT
	bool "Use Oneshot timer"
	---help---
		Use an MCU-specific oneshot timer as the external clock.  The
		oneshot timer must be configured by board specific logic which must
		then call:

			void nxsched_oneshot_extclk(FAR struct oneshot_lowerhalf_s *lower);

		To start the CPU load measurement. See include/nuttx/clock.h

		NOTE that in this configuration, CONFIG_SCHED_CPULOAD_TICKSPERSEC is
		the sample rate that will be accomplished by programming the oneshot
		time repeatedly.  If CPULOAD_ONESHOT_ENTROPY is also selected, then
		the underly frequency driving the oneshot timer must be
		significantly faster than CONFIG_SCHED_CPULOAD_TICKSPERSE to permit
		precise modulation the sample periods.

config CPULOAD_PERIOD
	bool "Use Period timer"
	---help---
		Use an MCU-specific period timer as the external clock.  The
		period timer must be configured by board specific logic which must
		then call:

			void nxsched_period_extclk(FAR struct timer_lowerhalf_s *lower);

		To start the CPU load measurement. See include/nuttx/clock.h

		NOTE that in this configuration, CONFIG_SCHED_CPULOAD_TICKSPERSEC is
		the sample rate that will be accomplished by programming the period
		time.

endchoice

config CPULOAD_ENTROPY
	int "Bits of entropy"
	default 6
	range 0 30
	---help---
		This is the number of bits of entropy that will be applied. The
		oneshot will be set to this interval:

			CPULOAD_ONESHOT_NOMINAL - (CPULOAD_ONESHOT_ENTROPY / 2) +
			error + nrand(CPULOAD_ONESHOT_ENTROPY)

		Where

			CPULOAD_ONESHOT_NOMINAL is the nominal sample interval implied
			by CONFIG_SCHED_CPULOAD_TICKSPERSEC in units of microseconds.
			CPULOAD_ONESHOT_ENTROPY is (1 << CONFIG_CPULOAD_ENTROPY),
			and 'error' is an error value that is retained from interval to
			interval so that although individual intervals are randomized,
			the average will still be CONFIG_SCHED_CPULOAD_TICKSPERSEC.

		This special value of zero disables entropy.

endif # SCHED_CPULOAD_EXTCLK

config SCHED_CPULOAD_TIMECONSTANT
	int "CPU load time constant"
	depends on !SCHED_CPULOAD_NONE
	default 2
	---help---
		The accumulated CPU count is divided by two when the accumulated
		tick count exceeds this time constant.  This time constant is in
		units of seconds.

config SCHED_PROFILE_TICKSPERSEC
	int "Profile sampling rate"
	default 1000
	---help---
		This is the frequency at which the profil function will sample the
		running program. The default is 1000Hz.

menuconfig SCHED_INSTRUMENTATION
	bool "System performance monitor hooks"
	default n
	select SCHED_SUSPENDSCHEDULER
	select SCHED_RESUMESCHEDULER
	---help---
		Enables instrumentation in scheduler to monitor system performance.
		If enabled, then the board-specific logic must provide the following
		functions (see include/sched.h):

			void sched_note_start(FAR struct tcb_s *tcb);
			void sched_note_stop(FAR struct tcb_s *tcb);

		If CONFIG_SMP is enabled, then these additional interfaces are
		expected:

			void sched_note_cpu_start(FAR struct tcb_s *tcb, int cpu);
			void sched_note_cpu_started(FAR struct tcb_s *tcb);

if SCHED_INSTRUMENTATION

config SCHED_INSTRUMENTATION_CPUSET
	hex "CPU bit set"
	default 0xffff
	depends on SMP && SCHED_INSTRUMENTATION_FILTER
	---help---
		Monitor only CPUs in the bitset.  Bit 0=CPU0, Bit1=CPU1, etc.

config SCHED_INSTRUMENTATION_FILTER
	bool "Instrumentation filter"
	default n
	---help---
		Enables the filter logic for the instrumentation. If this option
		is enabled, the instrumentation data passed to sched_note_add()
		can be filtered by syscall and IRQ number.
		The filter logic can be configured by sched_note_filter APIs defined in
		include/nuttx/sched_note.h.

config SCHED_INSTRUMENTATION_FILTER_DEFAULT_MODE
	hex "Default instrumentation filter mode"
	depends on SCHED_INSTRUMENTATION_FILTER
	default 0x3f
	---help---
		Default mode of the instrumentation filter logic.
			Bit 0 = Enable instrumentation
			Bit 1 = Enable switch instrumentation
			Bit 2 = Enable syscall instrumentation
			Bit 3 = Enable IRQ instrumentation
			Bit 4 = Enable dump instrumentation
			Bit 5 = Enable collecting syscall arguments

config SCHED_INSTRUMENTATION_SWITCH
	bool "Use note switch for instrumentation"
	default n
	---help---
		Use note switch for instrumentation.

			void sched_note_suspend(FAR struct tcb_s *tcb);
			void sched_note_resume(FAR struct tcb_s *tcb);

		If CONFIG_SMP is enabled, then these additional interfaces are
		expected:

			void sched_note_cpu_pause(FAR struct tcb_s *tcb, int cpu);
			void sched_note_cpu_paused(FAR struct tcb_s *tcb);
			void sched_note_cpu_resume(FAR struct tcb_s *tcb, int cpu);
			void sched_note_cpu_resumed(FAR struct tcb_s *tcb);

		NOTE: These are internal OS interfaces and are called at very
		critical locations in the OS. There is very little that can be
		done in these interfaces.  For example, normal devices may not be
		used; syslog output cannot be performed.

config SCHED_INSTRUMENTATION_PREEMPTION
	bool "Preemption monitor hooks"
	default n
	---help---
		Enables additional hooks for changes to pre-emption state.  Board-
		specific logic must provide this additional logic.

			void sched_note_preemption(FAR struct tcb_s *tcb, bool state);

config SCHED_INSTRUMENTATION_CSECTION
	bool "Critical section monitor hooks"
	default n
	select IRQCOUNT
	---help---
		Enables additional hooks for entry and exit from critical sections.
		Interrupts are disabled while within a critical section.  Board-
		specific logic must provide this additional logic.

			void sched_note_csection(FAR struct tcb_s *tcb, bool state);

config SCHED_INSTRUMENTATION_SPINLOCKS
	bool "Spinlock monitor hooks"
	default n
	---help---
		Enables additional hooks for spinlock state.  Board-specific logic
		must provide this additional logic.

		void sched_note_spinlock(FAR struct tcb_s *tcb, FAR volatile spinlock_t *spinlock, int type)

config SCHED_INSTRUMENTATION_SYSCALL
	bool "System call monitor hooks"
	default n
	depends on ARCH_HAVE_SYSCALL_HOOKS
	---help---
		Enables additional hooks for entry and exit from system call.
		Board-specific logic must provide this additional logic.

			void sched_note_syscall_enter(int nr, int argc, ...);
			void sched_note_syscall_leave(int nr, uintptr_t result);

config SCHED_INSTRUMENTATION_IRQHANDLER
	bool "Interrupt handler monitor hooks"
	default n
	---help---
		Enables additional hooks for interrupt handler. Board-specific logic
		must provide this additional logic.

			void sched_note_irqhandler(int irq, FAR void *handler, bool enter);

config SCHED_INSTRUMENTATION_HEAP
	bool "Heap monitor hooks"
	default n
	---help---
		Enables additional hooks for heap allocation.

			void sched_note_heap(uint8_t event, FAR void* heap, FAR void *mem, size_t size, size_t curused);

config SCHED_INSTRUMENTATION_WDOG
	bool "Watchdog timer monitor hooks"
	default n
	---help---
		Enables additional hooks for watchdog timer.

			void sched_note_wdog(uint8_t event, FAR void *handler, FAR const void *arg);

config SCHED_INSTRUMENTATION_DUMP
	bool "Use note dump for instrumentation"
	default n
	---help---
		Use note dump for instrumentation.

			void sched_note_event_ip(uint32_t tag, uintptr_t ip, uint8_t event, FAR const void *buf, size_t len);
			void sched_note_vprintf_ip(uint32_t tag, uintptr_t ip, FAR const char *fmt, uint32_t type, va_list va) printf_like(3, 0);
			void sched_note_printf_ip(uint32_t tag, uintptr_t ip, FAR const char *fmt, uint32_t type, ...) printf_like(3, 5);

config SCHED_INSTRUMENTATION_FUNCTION
	bool "Enable function auto-tracing"
	default n
	---help---
		After enabling this option, you can automatically trace the function instrumentation without adding tracepoint manually.
		This is similar to the Function Trace effect of the linux kernel
		Add CFLAGS += -finstrument-functions to the makefile to track the required modules.
		The following compilation option can exclude files that do not want to be tracked in this module
		CFLAGS += -finstrument-functions-exclude-file-list=xxx
		The following compilation option can exclude functions that do not want to be tracked in this module
		CFLAGS += -finstrument-functions-exclude-function-list=xxx
		For a more detailed description of compilation options,
		refer to the "Program Instrumentation Options" chapter in the gcc documentation

endif # SCHED_INSTRUMENTATION
endmenu # Performance Monitoring

menu "System Auto Instrumentation"

config SCHED_STACK_RECORD
	int "Maximum stack backtrace to record"
	default 0
	---help---
		Specifies the maximum number of stack backtrace to record in the
		TCB.  Useful if scheduler instrumentation is selected.  Set to zero
		to disable.Through instrumentation, record the backtrace at
		the deepest point in the stack.

endmenu

menuconfig PRIORITY_INHERITANCE
	bool "Enable priority inheritance"
	default n
	---help---
		Set to enable support for priority inheritance on mutexes and semaphores.
		When this option is enabled, the initial configuration of all seamphores
		and mutexes will be with priority inheritance enabled.  That configuration
		may not be appropriate in all cases (such as when the semaphore or mutex
		is used for signaling).  In such cases, priority inheritance can be
		disabled for individual semaphores by calling:

			int ret = sem_setprotocol(&sem, SEM_PRIO_NONE);

		From applications, the functionally equivalent OS internal interface,
		nxsem_set_protocol(), should be used within the OS

		And for individual pthread mutexes by setting the protocol attribute
		before initializing the mutex:

			int ret = pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_NONE);

if PRIORITY_INHERITANCE

config SEM_PREALLOCHOLDERS
	int "Number of pre-allocated holders"
	default 4 if DEFAULT_SMALL
	default 8 if !DEFAULT_SMALL
	---help---
		This setting is only used if priority inheritance is enabled.
		It defines the maximum number of different threads (minus one) that
		can take counts on a semaphore with priority inheritance support.
		This may be set to zero if priority inheritance is disabled OR if you
		are only using semaphores as mutexes (only one holder) OR if no more
		than two threads participate using a counting semaphore.

endif # PRIORITY_INHERITANCE

config PRIORITY_PROTECT
	bool "Enable priority protect"
	default n
	---help---
		When a thread locks a mutex it inherits the priority ceiling of the
		mutex, which is defined by the application as a mutex attribute.

menu "Stack and heap information"

config DEFAULT_TASK_STACKSIZE
	int "The default stack size for tasks"
	default 2048
	---help---
		The default stack size for tasks.

config IDLETHREAD_STACKSIZE
	int "Idle thread stack size"
	default 1024
	---help---
		The size of the initial stack used by the IDLE thread.  The IDLE thread
		is the thread that (1) performs the initial boot of the system up to the
		point where start-up application is spawned, and (2) there after is the
		IDLE thread that executes only when there is no other thread ready to run.

config PTHREAD_STACK_MIN
	int "Minimum pthread stack size"
	default 256
	---help---
		Minimum pthread stack size

config PTHREAD_STACK_DEFAULT
	int "Default pthread stack size"
	default DEFAULT_TASK_STACKSIZE
	---help---
		Default pthread stack size

endmenu # Stack and heap information

config SCHED_BACKTRACE
	bool "Stack BackTrace"
	default "n"
	---help---
		This option enables stack backtrace support in the NuttX
		using the information automatically generated by the
		compiler or architecture specific approach when ARCH_HAVE_BACKTRACE
		is selected

config GROUP_KILL_CHILDREN_TIMEOUT_MS
	int "Group kill children timeout"
	default -1
	depends on !DISABLE_PTHREAD && SIG_SIGKILL_ACTION
	---help---
		Kill children a SIGQUIT signal before cancel them,
		< 0 means wait until all the child thread exit
		> 0 means wait timeout
		= 0 means don't do kill signal

config PID_INITIAL_COUNT
	int "Initial length of pid table"
	default 8 if DEFAULT_SMALL
	default 16 if !DEFAULT_SMALL
	---help---
		This is the initial length of pid table, which the system
		can still expand when needed. It is rounded up to power of
		two by current implementation. If the number of threads in
		your system is known at design time, setting this to it.

config SCHED_EVENTS
	bool "Schedule Event objects"
	default n
	---help---
		This option enables event objects. Threads may wait on event
		objects for specific events, but both threads and ISRs may deliver
		events to event objects.

config ASSERT_PAUSE_CPU_TIMEOUT
	int "Timeout in millisecond to pause another CPU when assert"
	default 2000
	depends on SMP
	---help---
		Timeout in millisecond to pause another CPU when assert. Only available
		when SMP is enabled.
		Enable to support perf events.

config COREDUMP
	bool "Coredump support"
	depends on ARCH_HAVE_TCBINFO
	select LIBC_ARCH_ELF
	default n
	---help---
		Generate ELF core dump to provide information about the CPU state and the
		memory state of program.
		The memory state embeds a snapshot of all segments mapped in the
		memory space of the program. The CPU state contains register values
		when the core dump has been generated.

endmenu
